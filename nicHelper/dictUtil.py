# AUTOGENERATED! DO NOT EDIT! File to edit: dictUtil.ipynb (unless otherwise specified).

__all__ = ['printDict', 'allKeysInDict', 'filterDt', 'stripDict', 'hashDict', 'saveDictToFile', 'loadDictFromFile',
           'saveStringToFile', 'loadStringFromFile', 'genSchema']

# Cell
# from datetime import datetime

# Cell
def printDict(d:dict, length:int = 10, space = 0):
  '''
  print dictionary as first x value of values
  d: dict: the dictionary to be printed
  length: int: the length of the stuff being printed?
  space: int: space between key and value?
  '''
  if type(d) != dict:
    print('this is not a dict')
    print(d)
  else:
    for k, v in d.items():
      if type(v) == dict:
        print(f"{' '*space}{k}")
        printDict(v, space=space+1)
      else:
        print(f"{' '*space}{k} : {v[:length] if type(v)==str else v}")

# Cell
def allKeysInDict(inputDict:dict, keys:list):
  '''
  checks whether all the keys given in the list are also keys in the inputDict dictionary
  inputDict: dict: the dictionary inputted
  keys: list: the list of keys
  '''
  return all(key in inputDict for key in keys)

# Cell
def filterDt(dtDict:dict):
  '''
  convert unjsonable datetime object to timestamp in the dictionary, this works for nested dictionary as well
  dtDict: dict: the dictionary containing the datetime object
  '''
  from datetime import datetime
  return {k: (filterDt(v) if type(v) == dict else v) if type(v) != datetime else v.timestamp()
            for k,v in dtDict.items()}

# Cell
def stripDict(data:dict):
  '''
  if the value in the dictionary is a string, it will 'strip' the value to make it more clear
  data: dict: the dictionary inputted to be 'stripped'
  '''
  return {k: v.strip() if type(v) == str else v for k,v in data.items()}

# Cell
import hashlib, pickle, base64
def hashDict(data:dict, hasher= hashlib.sha1(), encoder = pickle.dumps):
  hasher.update(encoder(data))
  rawHash = hasher.digest()
  return base64.b64encode(rawHash).decode()

# Cell
import pickle
def saveDictToFile(data:dict, path:str):
  '''
  saves the dictionary to the file directed by the path
  data: dict: the dictionary to be saved
  path: str: the file path to the file the dictionary is going to be saved
  '''
  with open(path, 'wb')as f:
    pickle.dump(data,f,protocol=pickle.HIGHEST_PROTOCOL)

def loadDictFromFile(path:str):
  '''
  returns the dictionary that is saved in the file
  path: str: the path taken to the file of the dictionary
  '''
  with open(path, 'rb') as f:
    return pickle.load(f)

# Cell
def saveStringToFile(data:str, path:str):
  '''
  saves the string to the file directed by the path
  data: str: the string to be saved
  path: str: the file path to the file the string is going to be saved
  '''
  with open(path, 'w')as f:
    f.write(data)
def loadStringFromFile(path:str):
  '''
  returns the string that is saved in the file
  path: str: the path taken to the file of the string
  '''
  with open(path, 'r')as f:
    return f.read()

# Cell
def genSchema(inputDict:dict, format_='yaml')->(dict,str):
  '''generate a json schema from dict,
  format::dict or str:
    default='yaml', return schema in json or yaml
    'json', return the json schema
  response
    'both', return a tuple of (json, yaml)
  inputDict: dict: the dict inputted to be used to generate the schema
  '''
  from genson import SchemaBuilder
  import yaml
  builder = SchemaBuilder()
  builder.add_object(inputDict)
  schema = builder.to_schema()
  if format_=='yaml':
    return yaml.dump(schema)
  elif format_ == 'json':
    return schema
  elif format_ == 'both':
    return schema, yaml.dump(schema)
  else:
    return schema, yaml.dump(schema)